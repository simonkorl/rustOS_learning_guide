# 控制流——初级 part2

## for 与迭代器

### 迭代器 Iterator

迭代器是一个计算机编程中非常常见的概念。简单来说，它提供了一个功能：根据当前的状态，告诉你下一个状态返回值是什么。顾名思义，迭代器主要的功能就是进行“迭代”——对某个过程的重复，而迭代器返回的东西便是“迭代”后的结果。

我们可以自己定义迭代器，不过这将会在靠后的章节中提到，我们这里只是稍加介绍这个概念，并且介绍一个最为基础和简单的迭代器 Range 。

### Range

Range 是 Rust 内置的迭代器，可以生成一个范围内的整数。

Range 的含义可以理解为区间，`0..10`代表一个左闭右开的区间，可以生成范围为 `[0, 10)` 的整数迭代器；`0..=10`代表一个闭区间，生成 `[0,10]` 一共十一个整数的迭代器。

### for .. in 结构

`for`循环通过`for .. in ..`的结构对一个迭代器中的所有内容进行迭代。`for`循环每一次都会“从迭代器中取出”下一个值，然后利用这个值进行下一次循环。

下面是一个简单的示例：

```rust
fn main() {
    // 判断 [0, 9] 的整数的奇偶性
    for i in 1..10 {
        if i % 2 == 0 {
            println!("{} is even number", i);
        } else {
            println!("{} is odd number", i);
        }
    }
}
```

`for .. in ..`的大致原理是：每次尝试从迭代器中获取下一个元素，如果发现无法获取则退出，否则执行循环体内部的指令。

### iter 与 iter_mut

`for .. in ..`结构只能用于迭代迭代器中的内容，如果你提供的变量并不是迭代器，或是不能转化为迭代器（使用 into_iter trait）的话，那么就会发生编译错误。除了 Range 之外，之前提到过的基本数据类型 array 和 slice 也是可以进行迭代的，不过它们需要调用特定的函数进行转化（否则我们会失去它们，这在我们所有权的地方再进行解释）。

`iter`可以将 array 和 slice 转化为只读的迭代器，它返回的是原数组元素的一个“借用”（borrow）：你并没有获得原数组元素的一个拷贝，你只是把它在内存中的位置取了出来。

`iter_mut`与`iter`类似，不过这次使用的是`&mut`进行可变借用，你可以利用这个“引用”对原数组的中的元素进行修改。

下面是一段简单的示例代码：

```rust
fn main() {
    let mut array = [1, 2, 3, 4, 5]; // 定义一个可变数组，否则其中的元素不能被修改
    for i in array.iter_mut() { // 采用可变的方法借用成迭代器
        println!("{:p}: {} -> {}",i , i, *i + 2); // #1
        *i += 2; // 使用*号对引用中的值进行操作
    }
    println!("----------");
    for i in array.iter() { // 采用不可变的方式进行借用成迭代器
        println!("{:p}: {:?}", i, i); // #2
        // 以下的这行代码无法正确编译，原因是一般的借用不允许被修改
        // *i -= 2;
    }
}
```

这一段代码中，`#1`与`#2`所在行展示了变量`i`实际上是被作为“引用”进行访问的，不过通过一般的方法并不能直接打印出来变量`i`所代表的内存地址的值。在`#1`行中，如果要对“引用”`i`中的值进行操作（比如说与其他的变量进行加减），根据 Rust 的类型检查，你必须先将其解引用，即使用 * 符号获取到引用中的值才能正确的进行编译。其中的细节我们在具体说明“引用”的时候再进一步解释。

## 代码

有了`for`循环后，我们的控制流可以像许多其他语言一样得心应手地使用了。现在我们就来解决最为经典的“跳台阶”问题来试一试手吧。

题目如下：

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）

**示例1**

输入：

```bash
1
```

输出：

```bash
2
```

**示例2**

输入：

```bash
4
```

输出：

```bash
5
```

我们这里提供一个参考的实现框架：从命令行读入输入 n ，并且将输出直接打印在命令行上。只需要实现 solution 函数的函数体内容就可以。

```rust
/// 从键盘获得输入，返回解析的正整数值
/// 
/// 每一次输入使用回车确认
/// 
/// 在内部处理了输入失败或无法解析则会报错并且要求重新输入。
/// 
/// @returns u64 返回解析后的整数

fn get_uint64() -> u64 {
    println!("input an positive integer: ");
    loop { // 使用 loop 持续输入
        let mut input = String::new();
        if let Ok(_c_len) = std::io::stdin().read_line(&mut input) {
            input.pop();
            if let Ok(number) = input.parse::<u64>() {
                // 利用返回语句跳出 loop 循环
                return number;
            } else {
                // 解析失败
                println!("Parse failed, please input a positive integer");
            }
        } else {
            println!("Input failed! Please input again!");
        }
    }
}


struct Solution;
impl Solution {
    fn solution(n: u64) -> u64 {
        // TODO: 修改这个函数内的代码
        n
    }
}
fn main() {
    println!("{}", Solution::solution(get_uint64()));
}
```

我们提供一个简单的实现以作参考

```rust
impl Solution {
    // #3
    fn solution(n: u64) -> u64 {
        return {
            if n == 1 {
                1 // #1
            } else if n == 2 {
                2
            } else {
                let mut dp = [0u64; 3]; // 使用基本的动态规划的思路
                dp[0] = 1; // 上1节台阶有一种方法
                dp[1] = 2; // 上2节台阶有两种方法
                for _i in 3..=n { // #2
                    dp[2] = dp[0] + dp[1];
                    dp[0] = dp[1];
                    dp[1] = dp[2];
                }
                dp[2]
            }
        }
    }
}
```

## 代码说明

### #1

这个 return 语句的写法很奇怪，这是利用了`if .. else if .. else`语句的表达式的值来实现的。

`if`语句是有返回值的，如果你确保一个`if`语句的每一个分支都是类型相同的表达式，那么整个`if`语句就有一个唯一确定的类型，那么这个`if`语句就是一个有确定类型返回值的表达式。这里的写法就是直接把`if`要返回的值直接写在分支的表达式中，并且最后一同返回。

并不是所有的分支和循环语句都支持这种写法，比如`for`循环就有强制的返回类型`()`，也就是没有返回值。

### #2

实际上，在这个程序中我们只是简单的利用`for`循环进行了迭代操作，并没有使用变量`i`。Rust 会建议将没有使用的变量使用下划线进行标记。那么使用`for`循环的理由主要就是习惯。

### #3

如果你试一试这个参考程序的话，你会发现它其实计算不了太大的`n`，比如说在测试`n = 100`时就会直接报错退出，提醒发生了溢出的运算。因为斐波那契数列增长速度很快，所以 u64 类型都是不够支撑`n = 100`的情况。如果想要更大的结果需要处理大数。

不过 Rust 的这种特性也在一定程度上保证了内存安全，确保程序的每一步运行结果都是可控的。

## 小结

在这一节中，我们主要针对`for`循环进行了介绍，并且趁机说明了`for`循环所以依赖的“迭代器”相关概念。

你应该对以下内容有所掌握：

1. 熟练使用`for .. in ..`与 Range 进行简单的迭代操作

你应该对以下内容有所了解：

1. 迭代器的相关概念
2. `for`循环的大概实现原理
3. 利用`iter`或`iter_mut`来迭代 array 或 slice

## 参考资料

* [1] [Rust By Example: for loops](https://doc.rust-lang.org/rust-by-example/flow_control/for.html)

* [2] [Rust By Example: Iterators](https://doc.rust-lang.org/rust-by-example/trait/iter.html)

* [3] [跳台阶参考](https://blog.csdn.net/program_developer/article/details/82632065)