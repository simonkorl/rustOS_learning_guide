# 控制流——初级 part1

控制流的基本原理是：提供一个布尔类型的值，它只有真和假两个不同的值，根据真和假的不同值来决定程序不同的行为。这样就可以在程序中进行一些条件判断，并且产生不同的运行结果。这会使得程序变得更加灵活。这种可以使得程序进行判断的分支结构可以让程序完成许多依次执行无法简单完成的功能。

## 布尔表达式

在 ex13 中，我们已经提到了表达式的概念：一个没有分号的语句。那么“布尔表达式”当然就是值为一个布尔类型（true/false），只有真假两个值的表达式。

我们可以将它们打印出来：

```rust
fn main() {
    println!("{:?}", 1 > 2);
}
```

### 布尔表达式与强制转换

如果你使用过一些类 C 语言或是一些脚本语言，你会发现它们允许你把一些其他的类型作为布尔类型进行比较。比如说 C 语言中所有值不为 0 的变量，无论其类型，单独在 bool 表达式中都按“真”进行处理。这为编程带来了一些便利和简化，但是也带来了一些风险。

在 Rust 中不允许任何其他类型作为布尔表达式的结果。比如说你不能直接把一个空字符串转换为 bool 的“假”值，而在一些编程语言中，这种转换是允许发生的。

以下的代码**不能**成功编译：

```rust
fn main() {
    println!("{}", 1 as bool);
    println!("{}", "" as bool);
    println!("{}", () as bool);
}
```

## if, else

有了布尔表达式后，我们只需要在合适的地方使用这些布尔表达式就可以让程序有一些不同的行为了。那么最为基础的控制语句便是`if`语句。

`if`语句的运行逻辑如下：

1. 判断`if`语句的布尔表达式的值
   1. 如果为“真”则执行`if`语句后的 block
   2. 如果为“假”则检查当前`if`是否有`else`或者`else if`语句
      1. 如果有则执行对应的语句
      2. 如果没有则继续按顺序执行程序。

`if`语句是基础的判断语句，下面是一个示例。

```rust
fn main() {
    let n = 0;

    if n == 0 { // if 关键词后的表达式不需要使用小括号进行标记
        // if 语句后必须用大括号标记要执行的语句
        println!("n == 0");
    } else if n > 0 {
        println!("n > 0");
    } else {
        println!("n < 0");
    } // if 语句整体是一个表达式，最后不需要使用分号进行标记
}
```

## while

上面提到的`if/else`语句是最为基本的分支语句，它们使得程序可以根据条件执行不同的操作。

控制流中除了“分支”外，最关键的一个类型是“循环”。顾名思义，“循环”是为了让程序重复执行某一段内容，节约了需要手动书写重复代码的时间。

`while`语句便是最为基础的循环语句。与它自身的名字的含义基本上相同，在条件为真的时候，`while`语句会不断重复 block 中的内容，直到条件为假为止。

下面是一个简单的示例，可以打印 10 以内的所有自然数

```rust
fn main () {
    let mut n = 0;
    while n < 10 { // while 语句后必须使用一对大括号标记 while 所需要执行的语句。 while 语句的条件不需要使用小括号进行标记，不过这不会产生什么影响。
        println!("{}", n);
        n += 1;
    }
}
```

`while`语句的执行逻辑如下：

1. 判断 while 语句中的布尔表达式的值
   1. 如果为真，则执行大括号中的内容；
   2. 如果为假则不再执行括号中的内容，继续执行之后的语句

也就是说在执行动作之前先进行判断，如果条件不满足那么不会执行动作。

## break 与 continue

在循环中，我们也许希望程序有一些特殊的行为：比如说程序可以在特定条件达成的时候提前结束，或者是忽略一些内容。那么这个时候就需要使用`break`与`continue`关键词。

`break`关键词可以让你跳出某一个循环，默认是距离它最近的内侧循环，这会从`break`关键词的位置结束该循环，并且执行循环外的程序。

`continue`关键词则是让你立刻进行下一个循环，从该关键词的位置结束当前循环，并且执行下一次循环。

下面是一个示例

```rust
fn main() {
    let mut n = 0;
    while n < 10 {
        n += 1;
        if n % 2 == 0 {
            println!("n == {}, continue", n);
            continue;
            print!("Print nothing");
        } else if n == 9 {
            println!("n == 9, The End");
            break;
        } 
        else {
            println!("n == {}: Hello", n);
        }
    }
}
```

注意，`break`和`continue`不仅可以在`while`中使用，所有的循环语句都可以使用这两个关键词进行操作。

## loop

有一种循环是比较特殊的，比如说如果我书写一个如下的循环

```rust
while true {
    // do something
}
```

上面的循环就是一个不会停止的循环，因为不会有条件让`while`结束。我们可以称这样的循环是一个“死循环”或是一个“无限循环”。

Rust 提供了`loop`关键字来建立“无限循环”。这听起来非常奇怪，看似多次一举，但是`loop`具有一些自己的特性，来使得编程变得更加简单。

因为`loop`循环不能自己停止，所以想要让`loop`结束就必须要使用一些其他的方法让它停止。其中一种最为基础的方法就是使用判断语句和`break`

下面的程序使用`loop`和`break`打印整数 1~9

```rust
fn main() {
    let mut n = 0;
    loop {
        n += 1;
        println!("{}", n);
        if n >= 10 {
            break;
        }
    }
}
```

`loop`作为一种特殊的循环语句，它不能自己停止下来，必须要使用`break`或是其他的方法停止运行。不过 Rust 也为其提供了一些特殊的功能，使得其中的`break`关键词拥有比其他的循环中更加强大的中断功能，或是表达式值的返回。不过这部分内容我们将在“控制流——高级”部分进行介绍。目前只需要知道`loop`是一个无限循环就可以了。

## 代码

在这章中我们介绍了一些的分支以及循环的语句。有了这些语句我们就可以编写具有不同的行为的程序了。

我们利用这些语句来实现一个简单的打印某个整数以内的程序。我们在代码中给出了一个函数来进行输入、错误判断以及解析输入的操作，现在并不需要关心该函数中的相关内容的实现。

```rust
/// 从键盘获得输入，返回解析的正整数值
/// 
/// 每一次输入使用回车确认
/// 
/// 在内部处理了输入失败或无法解析则会报错并且要求重新输入。
/// 
/// @returns u64 返回解析后的整数
fn get_uint64() -> u64 {
    println!("input an positive integer: ");
    loop { // 使用 loop 持续输入
        let mut input = String::new();
        if let Ok(_c_len) = std::io::stdin().read_line(&mut input) {
            input.pop();
            if let Ok(number) = input.parse::<u64>() {
                // 利用返回语句跳出 loop 循环
                return number;
            } else {
                // 解析失败
                println!("Parse failed, please input a positive integer");
            }
        } else {
            println!("Input failed! Please input again!");
        }
    }
}
fn main() {
    let upper_bound: u64 = get_uint64();
    // 处理特殊情况
    if upper_bound <= 1{
        // 没有质数可以打印
    } else {
        let mut n = 2; // 从 2 开始枚举
        while n <= upper_bound {
            // 使用穷举法判断质数
            let mut i = 2;
            let mut flag = true;
            let prime_upper_bound = (n as f64).powf(0.5);

            if prime_upper_bound >= 2.0 {
                while i as f64 <= prime_upper_bound {
                    if n % i == 0 {
                        flag = false;
                        break;
                    }
                    i += 1;
                }
            }
            if flag {
                print!("{}, ", n)
            }
            n += 1;
        }
    }
    println!("\nThe end.");
}
```

## 本节总结

在本节中我们简单介绍了三种非常基础的控制流语句：`if .. else ..`, `while`与`loop`。在此基础上，我们还可以使用`break`和`continue`来控制循环语句的执行。

你应该对以下内容有所掌握：

1. 熟练使用本节介绍的三种不同的控制流语句和`break`, `continue`进行程序的编写

你应该对以下内容有所了解：

1. 大体了解这次编写的代码各部分的含义

## 碎碎念

### 顺序执行

在编写这一节的时候，我特意没有提到一个问题，就是为什么我们默认了程序是从上到下（在文件中）依次运行的。

实际上如果真有人问了这个问题，那么他/她可能发现了计算机中的一个关键问题，就是我们为什么要让程序从上到下依次运行呢？

从计算机体系结构的角度上来讲，程序通过编译形成了最后的机器码后，在机器上运行时还真不一定是按照编写的顺序进行运行的。有一些语句可以通过调整先后顺序来加速，有一些语句可以同时运行，有一些语句则依赖其他语句的结果，需要等待一段时间才能运行。如何合理地调整程序中语句的运行顺序，来使得程序运行得更快一直以来都是计算机相关技术研究的关键问题。那么程序设计语言中要认为程序是从上到下依次执行的呢？我猜的话是因为对于大部分人来说更好理解？否则可能存在那种从右往左书写或是从上往下竖向书写的程序设计语言吧。

## 参考资料

* [1] [Rust By Example: Flow of Control](https://doc.rust-lang.org/rust-by-example/flow_control.html)